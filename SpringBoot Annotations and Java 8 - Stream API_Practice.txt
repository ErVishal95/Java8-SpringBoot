Java 7,
Java 8,
Spring MVC,
JPA - Hibernate,
PL/SQL - proceddures


java 8 :-
Stream API,
Functional Interface,
Lambda expression,
ForEach() Method
Predicates and filters
Stream API aggrigate functions - list.stream.map(Class<T> :: getter).max(Comparator.naturalOrder());
																	.min(Comparator.naturalOrder());
																	.findFirst();
																	.sorted();
																	.sorted().findFirst();
																	.sorted(Comparator.reverseOrder());
																	.sorted(Comparator.reverseOrder()).findFirst();
																	.sorted().distince();
																	.sorted.limit(5/ any number);
																	.count();
									.stream().map(Employee:: getSalary).reduce(Float:: max);
									.stream().map(Employee:: getSalary).mapToDouble(i-> i).sum();
									.stream().map(Employee:: getSalary)
															.mapToDouble( i-> i)
															.average().ifPresent(avg -> System.out.println("Average of salary is: "+avg));
																	
Predicate examples:-

- public static Predicate<Employee> checkAgeLesserThen(Optional<Integer> age){
		return p-> p.getAge() < age.get()-20;
	}

- public static Predicate<Employee> isAgeGreaterThenAndDepartmentIs(int age, String department){
		return p-> p.getAge() > age && p.getDepartment().equalsIgnoreCase(department);
	}
	
Filters:-

- public static List<Employee> filterEmployee(List<Employee> employees, Predicate<Employee> predicate){
		return employees.stream().filter(predicate).collect(Collectors.<Employee>toList());
	}

implementation:-
-	Optional<Integer> maxAge = emplist.stream().map(Employee:: getAge).max(Comparator.naturalOrder());	//Max Age
		System.out.println(maxAge);
		
-		System.out.println(filterEmployee(emplist, checkAgeLesserThen(maxAge)));	
		
-	System.out.println(filterEmployee(emplist, isAgeGreaterThenAndDepartmentIs(25, "IT")));


Spring MVC & SpringBoot:-

Core Annotations-

@configuration - used to mark a class as source of Bean Definition, beans are the component that we need to wire.
@Bean - this annotation is a bean producer used along with @configuration annotation.
@componentScan - scan for the spring packages configured with it for @configuration classes.
@component - used for making a class as Spring Bean at auto - scan time.
@service - more specialised annotation of @component annotation.
@Autowire - to wire application component together, @Autowire annotation is used over - field, constructor, and mthods
@Lazy - Used for Lazy initialization or ondemand initialization. By default bean initialization is eager.
@Qualifier - can be used along with @Autowire annotation marked field if same field can be wired with multiple beans and one specific bean is required out of all available beans
@value - can be used to set the default value of a field.
@Required - if dependency injection need to be varified while wiring the bean using @Autowire annotation in more robust way, @Required annotation is best to use.
@Repository - used for dao operations and establishing the connection with database

SpringBoot and Web Annotations-

@SpringBootApplication - combination of (@configuration, @componentScan, @EnableAutoConfiguration)
@EnableAutoConfiguration - it helps Spring to guess configuration based on jars available at classpath.

@Controller - mark the class as web controller and handles the http requests
@ResponseBody - helps in binding the response for an incomming http reuest.
@RestController - combination of @Controller and @ResponseBody annotations
@RequestMapping(method = RequestMethod.Type, value = "/path") - used to get the path responsible for serving the Http requests 
@PathVariable("placeHolderName") - used to bring the value from URL via '/' to the method argument
@RequestParam/ @RequestParam(value = "value", required = false) - used to bring the value from URL via '?' or queries pased in the http requests to the method argument
@GetMapping
@PostMapping
@PutMapping
@DeleteMapping


JPA & Hibrnate:-

JPA 2.0 are available in javax.persistence package
@Entity - mark the POJO class as JPA Entity Bean (non- argument constructor is required)
@Id - Mark the field as primary Key, can be used over filed or getter method(best to use with getter as values can be modified easily via corresponding setter method)
@GeneratedValue(Strategy = GenerationType.AUTO) - Used for taking the primary key generation strategy.(By default generation strategy is AUTO)
@GeneratedValue(Strategy = GenerationType.IDENTITY) - database determine and assign the next primary key
@GeneratedValue(Strategy = GenerationType.TABLE) - IT keeps a saperate table with primary key values (@TableGenerator)
@GeneratedValue(Strategy = GenerationType.SEQUENCE) - Some databases support a SEQUENCE column type. It uses @SequenceGenerator

	SEQUENCE	@Id
				@SequenceGenerator(name="seq1",sequenceName="HIB_SEQ")
				@GeneratedValue(strategy=SEQUENCE,generator="seq1")
				private Integer employeeId;
				
	Table		@Id
				@GeneratedValue(strategy=GenerationType.TABLE , generator="employee_generator")
				@TableGenerator(name="employee_generator",
							   table="pk_table",
							   pkColumnName="name",
							   valueColumnName="value",
							   allocationSize=100)
				private Integer employeeId;
				
@Embeddable - for multi-column primary key, You must create a class to represent this primary key. mark this class with @Embeddable (this calss will have a field annotated with @Id annotation for primary key)
@EmbeddableId - used for composite primary key via class annotated with @Embeddable annotaion
@Table - The Table name thate need to be stored in DB can be customised further with this annotation. 
The @Table annotation provides four attributes, allowing you to override the name of the table, its catalog, and its schema, and to enforce unique constraints on columns in the table.
@SecondaryTable - Can be used to draw an attribute/field in an entity from secondry table
@Column - at the time of drawing attribute from secodry table into an entity, the attribute must be marked with @Column annotation with a table attribute identifying the table.
	
	@Entity
	@Table(name = "employee")
	@SecondaryTable(name = "employee_details")
	public class EmployeeEntity implements Serializable
	{
	   @Id
	   @GeneratedValue (strategy = GenerationType.SEQUENCE)
	   private Integer employeeId;
	   private String  firstName;
	   private String  lastName;
	 
	   @Column(table = "employee_details")
	   public String address;
	}

@UniqueConstraint - 
@Basic (fetch = FetchType.LAZY, optional = false) - to make a column as not null. 
@Column(name="FNAME",length=100,nullable=false)
@Transient - Fields that are used at run time can be discarded from object as they already persist in database, use @Transient on such fields.
@Temporal(TemporalType.TIME)